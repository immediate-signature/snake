IDEAL
model small
stack 100h
dataseg
message db 'game over, to play again press y$'
object_location dw 2
clock equ es:6ch
longer db 0
snake dw 2000 dup (0)
CODESEG
proc cleanscreen ; cleans the screen
	push cx
	push bx
	mov cx,4000d
	mov bx,0
	clean:
	mov [byte ptr es:bx],0
	inc bx
	loop clean
	pop bx
	pop cx
	ret
endp cleanscreen

proc startgame
mov ax, 0b800h
mov es, ax 
call cleanscreen
mov dl, '*'
mov dh,200
mov di,2000d;snake head first position
mov [es:di], dx
mov [es:di-2], dx
mov [es:di-4], dx
mov cx, 5
call random
ret
endp startgame

proc delay
push cx
push bx
	mov cx, 0ffffh ;delay loop
	lopa:
		mov bx, 20d
		lopb:
			dec bx
			cmp bx, 0
			jnz lopb
	loop lopa
	pop bx
	pop cx
	ret
endp delay

proc buffer
	mov ah,1
	int 16h
	jz nothingchanged
	mov ah,0
	int 16h
	nothingchanged:
ret
endp buffer

proc detect_direction
	cmp al, 'w'
	je up
	cmp al, 'a'
	je left
	cmp al, 'd'
	je right
	cmp al, 's'
	je  down
up: sub di,160
jmp move_on
down: add di,160d
jmp move_on
right: add di,2
jmp move_on
left: sub di,2
move_on:
ret
endp detect_direction

proc move_func
call delay
call check_if_eaten
call buffer
ret
endp move_func

proc random
push offset object_location
push ax
push bx
push cx
push si
push dx
push bp
mov bp,sp
mov ax, [clock] ; read timer counter
mov cx, [word cs:bx] ; read one byte from memory
xor si, cx ; xor memory and counter
and si, 2000d ; leaves value between 0-2000
sal si,1 ; mult value
mov [word ptr bp+12], si ; save in memory for future checking
mov dl,'@'
mov dh, 150
mov [es:si],dx                                                  
pop dx
pop si
pop cx
pop bx
pop ax
ret 2
endp random

proc check_if_eaten
push offset longer
push bp
mov bp,sp
mov [byte ptr bp+2], 0
cmp di, [object_location]
jne skip_increase
inc [byte ptr bp+12]
call random
skip_increase:
pop bp
ret 2
endp check_if_eaten

start:
	mov ax, @data
	mov ds, ax
	call startgame
	mov	[word ptr snake],1996d
	mov [word ptr snake+2], 1998d
	mov [word ptr snake+4], 2000d
	mov ah, 0
	int 16h
	snakemoving: 
		push ax
		push dx
		cmp  di, 160         ; Top row
		jb   stop_playing
		cmp  di, 3840        ; Bottom row
		ja   stop_playing
		mov  ax, di
		mov  dl, 160
		div  dl
		cmp  ah, 0           ; Left column
		je   stop_playing
		cmp  ah, 158         ; Right column
		jne  updatesnake  ; All 4 tests passed!
		stop_playing:
			pop dx
			pop ax
			jmp exit
	updatesnake:
		pop dx
		pop ax
		mov dl, '*'
		mov dh,200
		mov [es:di], dx
		mov bx, offset snake 
		cmp [longer],1 ;if longer is one , increase snake length
		je increa
		mov si, [bx]
		mov [word ptr es:si], 0 ; delete tail
		sub bx,2
		increa:
			add bx,2 ; prevent tail value from being deleted when being increased
		updateloop:
			mov si, [bx+2]
			mov [bx], si
			inc bx
		loop updateloop
		dec bx
		mov [word ptr bx], di
		cmp [longer],1
		jne reg
		add cx,2 ; this prevent inseting a junk value when increasing snake's length
	reg:
	call move_func
	jmp snakemoving
exit:
	call cleanscreen
	mov dx, offset message
	mov ah,9h
	int 21h
	mov ah,0
	int 16h
	cmp al, 'y'
	jne line
	jmp start
	line:
	mov ax, 4c00h
	int 21h
end start
