IDEAL
MODEL small
STACK 100h
DATASEG
message db 'GAME OVER, to play again press y$'
object_location dw 2
clock equ es:6Ch
longer db 0
snake_start dw  1996d,1998d,2000d
CODESEG
proc cleanscreen ; cleans the screen
	push cx
	push bx
	mov cx,4000d
	mov bx,0
	clean:
	mov [word ptr es:bx],0
	inc bx
	loop clean
	pop bx
	pop cx
	ret
endp cleanscreen

proc startgame
push dx
mov ax, 0b800h
mov es, ax 
call cleanscreen
mov dl, '*'
mov dh,200
mov di,2000d;snake head first position
mov [es:di], dx
mov [es:di-2], dx
mov [es:di-4], dx
mov	[word ptr snake_start], 1996d
mov [word ptr snake_start+1], 1998d
mov [word ptr snake_start +2] , 2000d
pop dx
mov cx, 3
call random
call detect_direction
ret
endp startgame

proc delay
push cx
push bx
	mov cx, 0FFFFh ;delay loop
	lopa:
		mov bx, 50D
		lopb:
			dec bx
			cmp bx, 0
			jnz lopb
	loop lopa
	pop bx
	pop cx
	ret
endp delay

proc detect_direction
	mov ah,1 ;checks keyboard buffer
	int 16h
	jz skip
directionloop:
mov ah,0h
int 16h
skip:
cmp al, 'w'
je up
cmp al, 'a'
je left
cmp al, 'd'
je right
cmp al, 's'
je  down
cmp al, 'q'
je gameover
jmp directionloop
up: call w
jmp directionloop
down: call s
jmp directionloop
right: call d
jmp directionloop
left: call a
JMP directionloop
gameover:call endgame
ret
endp detect_direction

proc w
sub di,160d
call move_func
ret
endp w

proc updatesnake
	push bx
	mov bx, [ snake_start ]; חשד לבעיה!! צריך להניס את התא שבו מוכנס  הדאטה
	cmp [longer] ,1 ;if longer is one , increase snake length
	JE INCREA
	mov [word ptr es:bx], 0 ; delete tail
	dec bx
	increa:
		mov [es:di], dx
		mov [word ptr es:si] , 0
		inc bx
	updateloop:
		mov si, [bx+1]
		mov [bx], si
		inc bx 
	loop updateloop
	mov [bx], di
	pop bx
ret 
endp updatesnake

proc s
add di,160
call move_func
ret
endp s

proc move_func
call updatesnake
call delay
call boundries
call check_if_eaten
call detect_direction
ret
endp move_func

proc a
sub di,2
call move_func
ret
endp a

proc d
add di,2
call move_func
ret
endp d

proc boundries
push ax
push dx
cmp di,160d
ja keep_playing
cmp di,3840d
jb keep_playing
mov ax,di
mov dl,160d
div dl
cmp ah,0
jne keep_playing
mov ax,di
inc ax
div dl
cmp ah,0
jne keep_playing
call endgame
keep_playing:
pop dx
pop ax
ret
endp boundries

proc random
push ax
push bx
push cx
push si
push dx
mov ax, [Clock] ; read timer counter
mov cx, [word cs:bx] ; read one byte from memory
xor si, cx ; xor memory and counter
and si, 2000d ; leaves value between 0-2000
sal si,1 ; mult value
mov [object_location], si ; save in memory for future checking
mov dl,'@'
mov dh, 150
mov [es:si],dx
pop dx
pop si
pop cx
pop bx
pop ax
ret
endp random

proc check_if_eaten
cmp di, [object_location]
mov [longer],0
jne skip_increase
inc cx
call random
mov [longer], 1
skip_increase:
ret
endp check_if_eaten

proc endgame
push dx
mov dx, offset message
mov ah,9
int 21h
mov ah,0
int 16h
cmp al, 'y'
jne line
pop dx
call startgame
line:
ret
endp endgame
start:
	mov ax, @data
	mov ds, ax
	call startgame
exit:
	mov ax, 4c00h
	int 21h
END start
