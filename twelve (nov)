IDEAL
MODEL small
STACK 100h
DATASEG
; --------------------------
snake_length db 0
object_location dw 1
message db 'GAME OVER, to play again press y$'
clock equ es:6Ch
; --------------------------
CODESEG
proc cleanscreen ; clean the screen
	push cx
	push bx
	mov cx,4000d
	mov bx,0
	clean:
	mov [word ptr es:bx],0
	inc bx
	loop clean
	pop bx
	pop cx
	ret
endp cleanscreen

proc startgame
mov ax, 0b800h
mov es, ax
call cleanscreen
push dx
mov dl, '*'
mov dh,200
mov di,2000
pop dx
mov [es:di], dx
mov [es:di-2], dx
mov [es:di-4], dx
push di
sub di,2
push di
sub di, 2
add di,4
push di
push bp
mov [snake_length], 6
call random
call detect_direction
ret
endp startgame

proc delay
push cx
push bx
	mov cx, 0FFFFh	
	lopa:
		mov bx, 50
		lopb:
			dec bx
			cmp bx, 0
			jnz lopb
	loop lopa
	pop bx
	pop cx
	mov ah,1
	int 16h
	jz skip
	call detect_direction
	skip:
	ret
endp delay

proc detect_direction
mostart:
mov ah,0
int 16h
push ax
cmp al, 'w'
je up
cmp al, 'a'
je left
cmp al, 'd'
je right
cmp al, 's'
je  down
cmp al, 'q'
je gameover
pop ax
up: call w
jmp mostart
down: call s
jmp mostart
right: call d
jmp mostart
left: call a
jmp mostart
gameover:call endgame
jmp mostart
ret
endp detect_direction

proc w
wagain:
sub di,160
call move_func
jmp wagain
ret
endp w

proc updatesnake
pop bp
mov si,[word bp+snake_length]
mov [word ptr es:si], 0
push di
push bp
ret 
endp updatesnake


proc s
sagain:
add di,160
call move_func
ret
endp s

proc move_func
call updatesnake
call delay
call boundries
call check_if_eaten
ret
endp move_func

proc a
aagain:
sub di,2
call move_func
jmp aagain
ret
endp a

proc d
dagain:
add di,2
call move_func
jmp dagain
ret
endp d

proc boundries
cmp di,160
ja keep_playing
cmp di,3840
jb keep_playing
push ax
push dx
mov ax,di
mov dl,160
div dl
cmp ah,0
jne keep_playing
mov ax,di
inc ax
div dl
cmp ah,0
call endgame
keep_playing:
pop dx
pop ax
ret
endp boundries

proc random
push ax
push bx
push cx
push si
mov ax, [Clock] ; read timer counter
mov cx, [word cs:bx] ; read one byte from memory
xor si, cx ; xor memory and counter
and si, 2000d ; leaves value between 0-2000
sal si,1 ; mult value
mov [object_location], si ; save in memory for future checking
pop si
pop cx
pop bx
pop ax
ret
endp random

proc check_if_eaten
cmp di, [object_location]
jne skip_increase
add [snake_length], 2
call random
skip_increase:
ret
endp check_if_eaten

proc endgame
push dx
mov dx, offset message
mov ah,9
int 21h
mov ah,0
int 16h
cmp al, 'y'
jne line
call startgame
line:
ret
endp endgame

start:
	mov ax, @data
	mov ds, ax
exit:
	mov ax, 4c00h
	int 21h
END start
